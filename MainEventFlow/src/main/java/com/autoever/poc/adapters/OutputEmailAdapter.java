package com.autoever.poc.adapters;

import java.io.File;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.Date;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.Properties;
import java.util.stream.Collectors;

import javax.activation.DataHandler;
import javax.activation.FileDataSource;
import javax.mail.Message;
import javax.mail.Multipart;
import javax.mail.Session;
import javax.mail.Transport;
import javax.mail.internet.AddressException;
import javax.mail.internet.InternetAddress;
import javax.mail.internet.MimeBodyPart;
import javax.mail.internet.MimeMessage;
import javax.mail.internet.MimeMultipart;
import javax.mail.internet.MimeUtility;

import com.streambase.sb.*;
import com.streambase.sb.adapter.*;
import com.streambase.sb.operator.*;


/**
* Generated by JDT StreamBase Client Templates (Version: 11.0.1).
*
* Output adapters take streams from an application and make them
* available outside of the application. Any implementation of 
* this class <b>must</b> extend class OutputAdapter. Output adapters
* should override method processTuple(int, Tuple) to receive tuples 
* from the application.
* <p>
* For in-depth information on implementing a custom adapter, please
* see "Developing StreamBase Embedded Adapters" in the StreamBase documentation.
* <p>
*/
public class OutputEmailAdapter extends OutputAdapter implements Parameterizable {

	public static final long serialVersionUID = 1730176953052L;
	// Properties
	private String SMTP_HOST;
	private String SMTP_ID;
	private String SMTP_PASS;
	private String SMTP_ADDR;
	private String displayName = "smtp Email adapter";
	
//	private final String ENCODING="EUC-KR";
	private final String ENCODING="UTF-8";
	private Properties mailProps = new Properties();

	/**
	* The constructor is called when the Adapter instance is created, but before the Adapter 
	* is connected to the StreamBase application. We recommended that you set the initial input 
	* port and output port count in the constructor by calling setPortHints(inPortCount, outPortCount). 
	* The default is no input ports or output ports. The constructor may also set default values for 
	* adapter parameters. These values will be displayed in StreamBase Studio when a new adapter is 
	* dragged to the canvas, and serve as the default values for omitted optional parameters.
	*/
	public OutputEmailAdapter() {
		super();
		setPortHints(1, 0);
		setDisplayName(displayName);
		setShortDisplayName(this.getClass().getSimpleName());
		setSMTP_HOST("10.7.20.48");
		setSMTP_ID("ZD00785");
		setSMTP_PASS("vdmsapp!02");
		setSMTP_ADDR("ZD00785@hyundai.com");

	}

	/**
	* Typecheck this adapter. The typecheck method is called after the adapter instance is
	* constructed, and once input ports are connected. The adapter should validate its parameters 
	* and throw PropertyTypecheckException (or TypecheckException) if any problems are found. 
	* The message associated with the thrown exceptions will be displayed in StreamBase Studio during authoring,
	* or printed on the console by sbd. Input adapters should set the schema of each output
	* port by calling the setOutputSchema(portNum, schema) method for each output port. 
	* If the adapter needs to change the number of input ports based on parameter values,
	* it should call requireInputPortCount(portCount) at this point. 
	*/
	public void typecheck() throws TypecheckException {
		// TODO Make sure all properties have valid values.

		try {
			Schema inputSchema = getInputSchema(0);
			inputSchema.getField("receiverList").checkType(CompleteDataType.forStringList());
			inputSchema.getField("message").checkType(CompleteDataType.forString());
			inputSchema.getField("notiCode").checkType(CompleteDataType.forString());
			inputSchema.getField("subject").checkType(CompleteDataType.forString());
		} catch(TupleException e) {
			throw new TypecheckException(e);
		}
	}

	/**
	* Initialize the adapter. If typecheck succeeds, the init method is called before
	* the StreamBase application is started. Note that your adapter is not required to
	* define the init method, unless you need to register a runnable or perform
	* initialization of a resource such as, for example, a JDBC pool.
	*/
	public void init() throws StreamBaseException {
		super.init();
		mailProps.put("mail.smtp.auth", "true");
	}

	/**
	* Shutdown adapter by cleaning up any resources used (e.g. close an output file
	* if it has been opened). When the application is shutting down, the adapter's shutdown.
	* method will be called first. Once this has returned, all threads should exit and the
	* adapter is considered shutdown.
	*/
	public void shutdown() {

	}

	/**
	 * This method will be called by the StreamBase server for each
	 * Tuple given to the adapter to process.  Output adapters should
	 * override this method to process tuples.
	 *<p>
	 * The default implementation does nothing.
	 * 
	 * @param inputPort the input port that the tuple is from (ports are zero based)
	 * @param tuple the tuple from the given input port
	 * @throws StreamBaseException Terminates the application. 
	
	 */
	@SuppressWarnings("unchecked")
	public void processTuple(int inputPort, Tuple tuple) throws StreamBaseException {

		if(tuple==null || tuple.isNull("receiverList") || tuple.isNull("message") || tuple.isNull("notiCode") || tuple.isNull("subject")) return;

		try {
			Map<String, Object> tupleMap = tuple.toMapView();
			String senderEmail = (String)Optional.ofNullable(tupleMap.get("senderEmail")).orElse(SMTP_ADDR);
			String senderName = (String)tupleMap.get("senderName");
			List<String> receiverList = (List<String>) tupleMap.get("receiverList");
			List<String> referenceList = (List<String>) tupleMap.get("referenceList");
			List<String> hiddenReferenceList = (List<String>) tupleMap.get("hiddenReferenceList");
			String notiCode= (String)tupleMap.get("notiCode");
			String subject = (String)tupleMap.get("subject");
			String message = (String)tupleMap.get("message");
			List<String> attachFilePaths = (List<String>)tupleMap.get("attachFilePaths");
			List<File> attachFiles = (attachFilePaths!=null && attachFilePaths.size()>0)? attachFilePaths.stream().map(pname->new File((String) pname)).collect(Collectors.toList()) : null;
			List<String> attachViewNames = (List<String>) tupleMap.get("attachViewNames");
	
			mailSend(senderEmail, senderName, receiverList, referenceList, hiddenReferenceList, notiCode, subject, message, attachFiles, attachViewNames);

		}catch(Exception e) {
			e.printStackTrace();
		}
	}
	
	public void mailSend(String senderEmail, String senderName, List<String> receiverList, List<String> referenceList, List<String> hiddenReferenceList, String notiCode, String subject, String bodyMessage, List<File> attachFiles, List<String> attachViewNames) throws Exception {
		Session session = Session.getInstance(mailProps);
		Message message = new MimeMessage(session);
		
		// 보내는 사람
		InternetAddress fromAddr = null;
		if(senderName==null) {
			fromAddr = new InternetAddress(senderEmail);
		}else {
			fromAddr = new InternetAddress(senderEmail, senderName, ENCODING);
		}
		message.setFrom(fromAddr);

		// 받는사람
		InternetAddress[] toAddrs = (InternetAddress[]) receiverList.stream().map(addr -> {
			try {
				return new InternetAddress(addr);
			} catch (AddressException e) {
				return null;
			}
		}).filter(e->e!=null).collect(Collectors.toList()).toArray(InternetAddress[]::new);
		message.setRecipients(Message.RecipientType.TO, toAddrs);
		
		// 참조 수신자.
		if(referenceList!=null && referenceList.size()>0) {
			InternetAddress[] ccAddrs = (InternetAddress[])referenceList.stream().map(addr-> {
				try {
					return new InternetAddress(addr);
				} catch (AddressException e) {
					return null;
				}
			}).filter(e->e!=null).collect(Collectors.toList()).toArray(InternetAddress[]::new);
			message.setRecipients(Message.RecipientType.CC, ccAddrs);
		}
		
		// 숨은참조 수신자
		if(hiddenReferenceList!=null && hiddenReferenceList.size()>0) {
			InternetAddress[] bccAddrs = (InternetAddress[])hiddenReferenceList.stream().map(addr-> {
				try {
					return new InternetAddress(addr);
				} catch (AddressException e) {
					return null;
				}
			}).filter(e->e!=null).collect(Collectors.toList()).toArray(InternetAddress[]::new);
			message.setRecipients(Message.RecipientType.BCC, bccAddrs);
		}
		
		//제목
		message.setSubject(subject);
		
		//메일 전체내용
		Multipart mp = new MimeMultipart();
		
		// 메일본문
		MimeBodyPart content = new MimeBodyPart();

		//body 메시지 변경
		//check 한글 인코딩
		StringBuilder bodyHtml = new StringBuilder().append("<pre>").append(bodyMessage).append("</pre><br/>");
		StringBuilder contentHtml = mailContents(bodyHtml, notiCode);

		
		content.setContent(contentHtml.toString(), "text/html; charset="+ENCODING);
		content.setHeader("Content-Transfer-Encoding", "base64");
		mp.addBodyPart(content);
		
		//첨부파일
		if(attachFiles!=null && attachFiles.size()>0) {
			attachFiles.stream().filter(elem->elem!=null).forEach(attachFile-> {
				MimeBodyPart attachFileMimeBodyPart = new MimeBodyPart();
				FileDataSource fds = new FileDataSource(attachFile);
				DataHandler dh = new DataHandler(fds);
				try {
					attachFileMimeBodyPart.setDataHandler(dh);
					Path path = Paths.get(attachFile.getCanonicalPath());
					attachFileMimeBodyPart.setHeader("Content-Type", Files.probeContentType(path));

					// 첨부화일명
					if(attachViewNames!=null && attachFiles.size()==attachViewNames.size()) {
						attachFileMimeBodyPart.setFileName(MimeUtility.encodeText(attachViewNames.get(attachFiles.indexOf(attachFile)), ENCODING, "B"));
					}else {
						attachFileMimeBodyPart.setFileName(MimeUtility.encodeText(attachFile.getName(), ENCODING, "B"));
					}

					mp.addBodyPart(attachFileMimeBodyPart);
				} catch (Exception e1) {
					// TODO Auto-generated catch block
					e1.printStackTrace();
				}
			});
		}
		message.setContent(mp);

		message.setSentDate(new Date());
		Transport transport = session.getTransport("smtp");

		try {
			transport.connect(
				SMTP_HOST,
				SMTP_ID,
				SMTP_PASS
			);
			
			transport.sendMessage(message, message.getAllRecipients());

		}finally {
			if(transport!=null) {
				transport.close();
			}
		}

	}
	
	public StringBuilder mailContents(StringBuilder body, String senderId) {

		//메일내용을 HTML로 구성
		StringBuilder contents = new StringBuilder();
		contents.append("<html xmlns='http://www.w3.org/1999/xhtml'>\n");
		contents.append("<head>\n");
		contents.append("<style>");
		contents.append("table{width:100%;min-height:30px;border:0px;border-collapse:collapse;table-layout:fixed;word-break:beak-all;}\n");
		contents.append("tr{text-align:center;}\n");
		contents.append("tr:nth-child(even){background:ghostwhite;}\n");
		contents.append("tr:nth-last-child(n){border-bottom:1px solid;}\n");
		contents.append("th{border:0px;width:150px;height:40px;border-left:1px dotted;border-right:1px dotted;border-top:1px solid gray;}\n");
		contents.append("td{border-left:1px dotted;border-right:1px dotted;border-top:1px solid lightgray;padding:5px;text-overflow:ellipsis;overflow:hidden;}\n");
		contents.append(".layer{display:block;width:93%;min-height:200px;max-height:400px;overflow:auto;}\n");
		contents.append("</style>\n");
		contents.append("</head>\n");
		contents.append("<body style='padding:10px; margin:0;'><br/>\n");
		contents.append(body).append("<br/><br/><hr/><h4>※ 이 메일은 발신전용메일입니다.</h4><h6 style='text-align:right;'>[발송코드 :" + senderId + "]</h6><br/>\n");
		contents.append("</body>\n");
		contents.append("</html>\n");
		
		return contents;
	}
	
   public StringBuilder mailContents2(StringBuilder body, int thWidth, String senderId) {

	   //메일내용을 HTML로 구성
        StringBuilder contents = new StringBuilder();
        contents.append("<html xmlns='http://www.w3.org/1999/xhtml'>\n");
        contents.append("<head>\n");
        contents.append("<style>");
        contents.append("table{width:100%;min-height:30px;border:0px;border-collapse:collapse;table-layout:fixed;word-break:beak-all;}\n");
        contents.append("tr{text-align:center;}\n");
        contents.append("tr:nth-child(even){background:ghostwhite;}\n");
        contents.append("tr:nth-last-child(n){border-bottom:1px solid;}\n");
        contents.append("th{border:0px;width:");
        contents.append(thWidth);
        contents.append("px;height:40px;border-left:1px dotted;border-right:1px dotted;border-top:1px solid gray;}\n");
        contents.append("td{border-left:1px dotted;border-right:1px dotted;border-top:1px solid lightgray;padding:5px;text-overflow:ellipsis;overflow:hidden;}\n");
        contents.append(".layer{display:block;width:93%;min-height:200px;max-height:400px;overflow:auto;}\n");
        contents.append("</style>\n");
        contents.append("</head>\n");
        contents.append("<body style='padding:10px; margin:0;'><br/>\n");
        contents.append(body).append("<br/><br/><hr/><h4>※ 이 메일은 발신전용메일입니다.</h4><h6 style='text-align:right;'>[발송코드 :" + senderId + "]</h6><br/>\n");
        contents.append("</body>\n");
        contents.append("</html>\n");
        
        return contents;
    }
	

	/***************************************************************************************
	 * The getter and setter methods provided by the Parameterizable object.               *
	 * StreamBase Studio uses them to determine the name and type of each property         *
	 * and obviously, to set and get the property values.                                  *
	 ***************************************************************************************/

	public void setSMTP_HOST(String SMTP_HOST) {
		this.SMTP_HOST = SMTP_HOST;
	}

	public String getSMTP_HOST() {
		return this.SMTP_HOST;
	}

	public void setSMTP_ID(String SMTP_ID) {
		this.SMTP_ID = SMTP_ID;
	}

	public String getSMTP_ID() {
		return this.SMTP_ID;
	}

	public void setSMTP_PASS(String SMTP_PASS) {
		this.SMTP_PASS = SMTP_PASS;
	}

	public String getSMTP_PASS() {
		return this.SMTP_PASS;
	}

	public void setSMTP_ADDR(String SMTP_ADDR) {
		this.SMTP_ADDR = SMTP_ADDR;
	}

	public String getSMTP_ADDR() {
		return this.SMTP_ADDR;
	}

	/** For detailed information about shouldEnable methods, see interface Parameterizable java doc 
	 *  @see Parameterizable 
	 */

	public boolean shouldEnableSMTP_HOST() {
		// TODO implement custom enablement logic here
		return true;
	}

	public boolean shouldEnableSMTP_ID() {
		// TODO implement custom enablement logic here
		return true;
	}

	public boolean shouldEnableSMTP_PASS() {
		// TODO implement custom enablement logic here
		return true;
	}

	public boolean shouldEnableSMTP_ADDR() {
		// TODO implement custom enablement logic here
		return true;
	}

}
